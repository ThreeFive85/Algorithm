// https://programmers.co.kr/learn/courses/30/lessons/12945

export const solution = (n) => {
    var answer = [0,1];
    if(n > 2){
        for(let i = 2; i < n+1; i++){
            answer.push((answer[i-1] + answer[i-2])%1234567);
        }
    }
    
    return answer[answer.length-1];
}

// 일반적인 프로그래밍 언어는 CPU에서 제공하는 최소 읽기 단위(word라고 하는 것으로 기억합니다)를 기준으로 변수의 범위를 지정 
// 일반적인 x86 시스템(인텔이나 AMD가 만든 그거입니다)은 word의 크기가 4byte라고 가정하며, 
// 그렇기 때문에 int라는 자료형은 -2,147,483,648 ~ 2,147,483,647까지의 값만을 표현(계산해보시면 총 숫자 개수가232 개. 1 바이트는 8비트)
// 예를 들어서 2,147,483,647을 저장하고 있는 int 변수에 1을 더하면 그 숫자는 
// 2,147,483,648이 아닌, -2,147,483,648이 됩니다(이는 2의 보수라는 개념)
// 다시 말해서, 각각의 변수가 사용하는 자료형은 사용할 수 있는 숫자의 범위가 있고, 이를 벗어나면 예상치 못한 이상한 결과. 
// 그런데 피보나치 수는 엄청나게 빠르게 증가. 44번째 피보나치 수만 가도 2,971,215,073로 int 범위를 넘음. 
// 이대로면 피보나치의 수를 구하라는 문제는 int를 사용할 수가 없지만 다음의 성질을 이용하여 구할 수 있음 
// 숫자 A, B, C가 있다고 하면 (A + B) % C의 값은 ( ( A % C ) + ( B % C) ) % C와 같다는 성질(참고 모듈러 연산의 성질)
// 조금만 숫자가 커져도 피보나치는 int로 표현할 수 있는 범위를 넘겨버리는데, 매번 1234567로 나눈 나머지만을 저장하는 것은 int의 범위에서 가능
// (당연하다면 당연하지만, 1234567로 나눈 나머지는 항상 1234567보다 작음). 
// 테스트에서 실패의 경우는 n번째 피보나치 수라고 구한 숫자가 이미 int의 범위를 넘긴 상태라 엉망진창이 된 상태, 
// 이것을 1234567로 나눈다고 한들 정확한 값을 구하는 것은 불가능.
